{"version":3,"sources":["../lib/park.js"],"names":["GeoLocation","require","DebugLog","Promise","moment","random_useragent","Settings","Ride","DefaultTimeFormat","s_parkName","Symbol","s_parkTimezone","s_parkGeolocation","s_parkTimeFormat","s_useragent","s_cacheTimeWaitTimes","s_rideIDToIDXMap","s_waitTimeStore","cacheKey","s_cacheKeyWaitTimes","Park","options","new","target","TypeError","name","DefaultParkName","timezone","DefaultParkTimezone","timeFormat","DefaultParkTimeFormat","cacheWaitTimesLength","tz","zone","Error","latitude","longitude","UserAgent","useragent","ua","osName","Rides","constructor","callback","GetWaitTimesPromise","then","data","error","ride","Dbg","id","undefined","className","substr","length","newRide","ride_id","ride_name","push","wait_time","rideObject","GetRideObject","WaitTime","resolve","reject","SupportsWaitTimes","Name","Cache","get","err","ridedata","Log","i","fromJSON","result","toJSON","FetchWaitTimes","set","ttl","DefaultCacheWaitTimesLength","console","bind","Timezone","format","arguments","getRandom","module","exports"],"mappings":"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","file":"park.js","sourcesContent":["\"use strict\";\r\n\r\n// our simple geolocation object library\r\nvar GeoLocation = require('./geoLocation.js');\r\n// a basic debug log wrapper\r\nvar DebugLog = require('./debugPrint.js');\r\n\r\n// include our Promise library\r\nvar Promise = require(\"./promise\");\r\n\r\n// MomentJS time library\r\nvar moment = require(\"moment-timezone\");\r\n// random useragent generator\r\nvar random_useragent = require(\"random-useragent\");\r\n\r\n// load user settings\r\nvar Settings = require(\"./settings\");\r\n\r\n// our Ride object\r\nvar Ride = require(\"./ride\");\r\n\r\n// default time format for returning times\r\nvar DefaultTimeFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\r\n\r\n// park symbols\r\nvar s_parkName = Symbol();\r\nvar s_parkTimezone = Symbol();\r\nvar s_parkGeolocation = Symbol();\r\nvar s_parkTimeFormat = Symbol();\r\nvar s_useragent = Symbol();\r\nvar s_cacheTimeWaitTimes = Symbol();\r\n// track which Ride ID is at which index in our Rides array\r\nvar s_rideIDToIDXMap = Symbol();\r\n\r\n// ride wait time storage\r\nvar s_waitTimeStore = Symbol();\r\n\r\n// key for generic cached data\r\nvar cacheKey = \"themeparks_cache_\";\r\n// at end of constructor, generate the cache key for this park and store it privately here\r\nvar s_cacheKeyWaitTimes = Symbol();\r\n\r\n/**\r\n * Park class handles all the base logic for all implemented themeparks.\r\n * All parks should inherit from this base class.\r\n * Any common functionality is implemented here to save endless re-implementations for each park.\r\n * @class\r\n */\r\nclass Park {\r\n  /**\r\n   * Create a new Park object\r\n   * @param {Object} options\r\n   * @param {String} options.name The name of this park\r\n   * @param {String} options.timezone Park's timezone\r\n   * @param {String} [options.timeFormat] Format to display park dates in\r\n   * @param {Number} [options.cacheWaitTimesLength=300] How long (in seconds) to cache wait times before fetching fresh time\r\n   * @param {Number} options.latitude Park's latitude\r\n   * @param {Number} options.longitude Park's longitude\r\n   * @param {String} [options.useragent] Useragent to use when making HTTP requests\r\n   */\r\n  constructor(options = {}) {\r\n    // can only construct actual parks, not the park object itself\r\n    //  see https://stackoverflow.com/questions/29480569/does-ecmascript-6-have-a-convention-for-abstract-classes\r\n    if (new.target === Park) {\r\n      throw new TypeError(\"Cannot create Park object directly, only park implementations of Park\");\r\n    }\r\n\r\n    // take base variables from the constructor\r\n    //  these variables should be present for all parks\r\n    // what's up with these OR things?\r\n    //  by default, use any manually passed in options\r\n    //  finally, fallback on the default settings\r\n    this[s_parkName] = options.name || Settings.DefaultParkName;\r\n    this[s_parkTimezone] = options.timezone || Settings.DefaultParkTimezone;\r\n    this[s_parkTimeFormat] = options.timeFormat || Settings.DefaultParkTimeFormat;\r\n\r\n    // cache settings\r\n    //  how long wait times are cached before fetching new data\r\n    this[s_cacheTimeWaitTimes] = options.cacheWaitTimesLength;\r\n\r\n    // validate park's timezone with momentjs\r\n    if (!moment.tz.zone(this[s_parkTimezone])) {\r\n      throw new Error(`Invalid timezone ${this[s_parkTimezone]} passed to park constructor.`);\r\n    }\r\n\r\n    // create a geolocation object if we've been passed a longitude and latitude\r\n    if (!this[s_parkGeolocation] && typeof(options.latitude) == \"number\" && typeof(options.longitude) == \"number\") {\r\n      this[s_parkGeolocation] = new GeoLocation({\r\n        longitude: options.longitude,\r\n        latitude: options.latitude\r\n      });\r\n    }\r\n\r\n    // validate our geolocation object has been created\r\n    if (!this[s_parkGeolocation]) {\r\n      throw new Error(`No park GeoLocation object created for ${this.name}. Please supply longitude and latitude for this park.`);\r\n    }\r\n\r\n    // set useragent, or if no useragent has been set, create a random Android one by default\r\n    this.UserAgent = options.useragent || function(ua) {\r\n      return (ua.osName == \"Android\");\r\n    };\r\n\r\n    // initialise the Rides array\r\n    this.Rides = [];\r\n    // also initialise our ride ID -> idx map\r\n    this[s_rideIDToIDXMap] = {};\r\n\r\n    // generate cache keys for this park (use cacheKey, the name of this object, _waittimes)\r\n    this[s_cacheKeyWaitTimes] = `${cacheKey}${this.constructor.name}_waittimes`;\r\n  }\r\n\r\n  /**\r\n   * Get waiting times for rides from this park\r\n   * Callback will call with callback(error, data)\r\n   * Data will be null if error is present\r\n   */\r\n  GetWaitTimes(callback) {\r\n    // translate the promise result into a \"classic\" callback response\r\n    this.GetWaitTimesPromise().then(function(data) {\r\n      callback(null, data);\r\n    }, function(error) {\r\n      callback(error);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch the ride data for the requested ID. If it doesn't exist, add a new ride to our park's ride set\r\n   * @param {Object} ride - Ride data to apply\r\n   * @param {String} ride.id - Ride's ID\r\n   * @param {String} ride.name - Ride's name\r\n   * @returns {Ride} ride - Newly created (or the existing) Ride object\r\n   */\r\n  GetRideObject(ride = {}) {\r\n    if (!ride) {\r\n      this.Dbg(\"No Ride Data supplied to GetRideObject\");\r\n      return null;\r\n    }\r\n    if (ride.id === undefined) {\r\n      this.Dbg(\"No Ride ID supplied to GetRideObject\", ride);\r\n      return null;\r\n    }\r\n    if (ride.name === undefined) {\r\n      this.Dbg(\"No Ride name supplied to GetRideObject\", ride);\r\n      return null;\r\n    }\r\n\r\n    // prepend the park's class name to the ID to attempt to ensure uniqueness\r\n    var className = this.constructor.name;\r\n    if (ride.id.substr(0, className.length) !== className) {\r\n      ride.id = `${className}_${ride.id}`;\r\n    }\r\n\r\n    // check if we don't already have this ride in our data set\r\n    if (this[s_rideIDToIDXMap][ride.id] === undefined) {\r\n\r\n      // new ride! add to our set\r\n      var newRide = new Ride({\r\n        ride_id: ride.id,\r\n        ride_name: ride.name,\r\n      });\r\n\r\n      // add our new ride to our ride list and make an ID mapping\r\n      this.Rides.push(newRide);\r\n      this[s_rideIDToIDXMap][ride.id] = this.Rides.length - 1;\r\n    }\r\n\r\n    // else, don't worry about it, fail quietly\r\n    // return the already existing ride\r\n    return this.Rides[this[s_rideIDToIDXMap][ride.id]];\r\n  }\r\n\r\n  /**\r\n   * Set a new wait time for a ride\r\n   * @param {Object} ride - Ride data to apply\r\n   * @param {String} ride.id - Ride's ID\r\n   * @param {String} ride.name - Ride's name\r\n   * @param {Number} ride.wait_time - Ride's new wait time (set < 0 to signify inactive ride)\r\n   */\r\n  SetRideWaitTime(ride = {}) {\r\n    if (!ride) return this.Dbg(\"No Ride Data supplied\");\r\n    if (ride.id === undefined) return this.Dbg(\"No Ride ID supplied to SetRideWaitTime\", ride);\r\n    if (ride.name === undefined) return this.Dbg(\"No Ride name supplied to SetRideWaitTime\", ride);\r\n    if (ride.wait_time === undefined) return this.Dbg(\"No wait time supplied to SetRideWaitTime\", ride);\r\n\r\n    // set ride's new wait time\r\n    var rideObject = this.GetRideObject(ride);\r\n    rideObject.WaitTime = ride.wait_time;\r\n  }\r\n\r\n  /** \r\n   * Get waiting times for rides from this park\r\n   * @returns {Promise}\r\n   */\r\n  GetWaitTimesPromise() {\r\n    return new Promise(function(resolve, reject) {\r\n      // do we actually support wait times?\r\n      if (!this.SupportsWaitTimes) {\r\n        return reject(`${this.Name} doesn't support fetching wait times`);\r\n      }\r\n\r\n      // check our cache first\r\n      Settings.Cache.get(this[s_cacheKeyWaitTimes], function(err, ridedata) {\r\n        if (!err && ridedata) {\r\n          this.Log(`Cache hit for ${this[s_cacheKeyWaitTimes]}!`);\r\n\r\n          // we have ridedata from the cache! apply over our current ride data\r\n          for (var i = 0, ride; ride = ridedata[i++];) {\r\n            // restore ride state from cache\r\n            this.GetRideObject(ride).fromJSON(ride);\r\n          }\r\n\r\n          // make an array of all the ride states\r\n          var result = [];\r\n          for (var i = 0, ride; ride = this.Rides[i++];) {\r\n            result.push(ride.toJSON());\r\n          }\r\n          return resolve(result);\r\n        }\r\n\r\n        // cache missing key or the cached data has expired. Fetch new data!\r\n        this.FetchWaitTimes().then(function() {\r\n          // success! the this.Rides array should now be populated\r\n          //  cache the Rides array and return result\r\n          var result = [];\r\n          for (var i = 0, ride; ride = this.Rides[i++];) {\r\n            result.push(ride.toJSON());\r\n          }\r\n\r\n          Settings.Cache.set(this[s_cacheKeyWaitTimes], result, {\r\n            // either use the options.cacheWaitTimesLength or the default cache time length\r\n            ttl: this[s_cacheTimeWaitTimes] || Settings.DefaultCacheWaitTimesLength\r\n          }, function(err) {\r\n            if (err) {\r\n              // if we error, console out, but don't fail (still return data)\r\n              console.error(\"Error setting cache data for key \" + this[s_cacheKeyWaitTimes]);\r\n            }\r\n\r\n            // return wait time data\r\n            resolve(result);\r\n          });\r\n        }.bind(this), function(err) {\r\n          // failed to fetch wait times, reject Promise\r\n          return reject(`Error fetching park wait times: ${err}`);\r\n        }.bind(this));\r\n      }.bind(this));\r\n    }.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Get this park's geolocation object\r\n   * @type {GeoLocation}\r\n   * */\r\n  get Location() {\r\n    return this[s_parkGeolocation];\r\n  }\r\n\r\n  /**\r\n   * Get this park's name in a human-readable form\r\n   * @type {String}\r\n   * */\r\n  get Name() {\r\n    return this[s_parkName];\r\n  }\r\n\r\n  /**\r\n   * Get this park's useragent string for making network requests\r\n   * This is usually randomly generated on object construction\r\n   * @type {String}\r\n   */\r\n  get UserAgent() {\r\n    return this[s_useragent];\r\n  }\r\n\r\n  /**\r\n   * Set this park's useragent\r\n   * Can set user agent to a defined string or use a generator function (see random-useragent library)\r\n   * @type {string|function} \r\n   */\r\n  set UserAgent(useragent = null) {\r\n    if (!useragent) throw new Error(\"No configuration passed to UserAgent setter\");\r\n\r\n    if (typeof(useragent) == \"function\") {\r\n      // generate a useragent using a generator function\r\n      this[s_useragent] = random_useragent.getRandom(useragent);\r\n    } else if (typeof(useragent) == \"string\") {\r\n      // set useragent using supplied static string\r\n      this[s_useragent] = useragent;\r\n    } else {\r\n      throw new Error(\"Must define either static user agent string or a generator function\");\r\n    }\r\n\r\n    this.Log(\"Set useragent to \" + this.UserAgent);\r\n  }\r\n\r\n  /**\r\n   * Get this park's Timezone\r\n   * @type {String}\r\n   * */\r\n  get Timezone() {\r\n    return this[s_parkTimezone];\r\n  }\r\n\r\n  /**\r\n   * Get park's current time\r\n   * @returns {string} Time as formatted by park's timeformat, or the default timeformat if set to null\r\n   * */\r\n  TimeNow({\r\n    timeFormat = null\r\n  } = {}) {\r\n    // take time right now, convert now into park's timezone and format it\r\n    //  format in preferred order of, manually passed in format, park's default time format, or global default time format\r\n    return moment().tz(this.Timezone).format(timeFormat || this[s_parkTimeFormat] || DefaultTimeFormat);\r\n  }\r\n\r\n  /**\r\n   * Does this park offer fast-pass services?\r\n   * @type {Boolean}\r\n   */\r\n  get FastPass() {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Does this park offer wait time information?\r\n   * @type {Boolean}\r\n   */\r\n  get SupportsWaitTimes() {\r\n    // base this logic solely on the presence of a function \"FetchWaitTimes\" existing\r\n    return this.FetchWaitTimes !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Debug print a message (when NODE_DEBUG=themeparks is set in environment)\r\n   * @param {...*} ToPrint Objects/strings to print\r\n   * */\r\n  Log() {\r\n    return DebugLog(`${this.constructor.name}:`, ...arguments);\r\n  }\r\n\r\n  /**\r\n   * Setup park for offline tests. Each park should define URLs to intercept to provide offline unit tests.\r\n   * @returns {bool} Whether offline tests were successfully setup\r\n   */\r\n  SetupOfflineTests() {\r\n    // default park doesn't add any network overrides, implement this per-park\r\n\r\n    // return false by default, to ensure parks actually implement this\r\n    return false;\r\n  }\r\n}\r\n\r\n// export the Park class\r\nmodule.exports = Park;"]}