{"version":3,"sources":["../lib/park.js"],"names":["GeoLocation","require","DebugLog","Promise","moment","random_useragent","Settings","Ride","Schedule","DefaultTimeFormat","s_parkName","Symbol","s_parkTimezone","s_parkGeolocation","s_parkTimeFormat","s_parkDateFormat","s_useragent","s_cacheTimeWaitTimes","s_cacheTimeOpeningTimes","s_rideIDToIDXMap","s_scheduleData","cacheKey","s_cacheKeyWaitTimes","s_cacheKeyOpeningTimes","Park","options","new","target","TypeError","name","DefaultParkName","timezone","DefaultParkTimezone","timeFormat","DefaultParkTimeFormat","dateFormat","DefaultDateFormat","cacheWaitTimesLength","cacheOpeningTimesLength","tz","zone","Error","latitude","longitude","UserAgent","useragent","ua","osName","Rides","constructor","callback","arguments","length","GetWaitTimesPromise","then","data","bind","error","ride","Dbg","id","undefined","className","substr","newRide","ride_id","ride_name","push","wait_time","rideObject","GetRideObject","WaitTime","FindRideObject","SetDate","resolve","reject","SupportsWaitTimes","Name","Cache","get","err","ridedata","Log","i","fromJSON","result","toJSON","FetchWaitTimes","set","ttl","DefaultCacheWaitTimesLength","GetOpeningTimesPromise","SupportsOpeningTimes","openingTimesData","GetDateRange","startDate","endDate","add","FetchOpeningTimes","IsDirty","DefaultCacheOpeningTimesLength","Timezone","format","TimeNow","getRandom","module","exports"],"mappings":"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","file":"park.js","sourcesContent":["\"use strict\";\r\n\r\n// our simple geolocation object library\r\nvar GeoLocation = require(\"./geoLocation.js\");\r\n// a basic debug log wrapper\r\nvar DebugLog = require(\"./debugPrint.js\");\r\n\r\n// include our Promise library\r\nvar Promise = require(\"./promise\");\r\n\r\n// MomentJS time library\r\nvar moment = require(\"moment-timezone\");\r\n// random useragent generator\r\nvar random_useragent = require(\"random-useragent\");\r\n\r\n// load user settings\r\nvar Settings = require(\"./settings\");\r\n\r\n// our Ride object\r\nvar Ride = require(\"./ride\");\r\n// our Schedule class\r\nvar Schedule = require(\"./schedule\");\r\n\r\n// default time format for returning times\r\nvar DefaultTimeFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\r\n\r\n// park symbols\r\nvar s_parkName = Symbol();\r\nvar s_parkTimezone = Symbol();\r\nvar s_parkGeolocation = Symbol();\r\nvar s_parkTimeFormat = Symbol();\r\nvar s_parkDateFormat = Symbol();\r\nvar s_useragent = Symbol();\r\nvar s_cacheTimeWaitTimes = Symbol();\r\nvar s_cacheTimeOpeningTimes = Symbol();\r\n// track which Ride ID is at which index in our Rides array\r\nvar s_rideIDToIDXMap = Symbol();\r\n// key for our schedule data\r\nvar s_scheduleData = Symbol();\r\n\r\n// key for generic cached data\r\nvar cacheKey = \"themeparks_cache_\";\r\n// at end of constructor, generate the cache keys for this park and store it privately here\r\nvar s_cacheKeyWaitTimes = Symbol();\r\nvar s_cacheKeyOpeningTimes = Symbol();\r\n\r\n/**\r\n * Park class handles all the base logic for all implemented themeparks.\r\n * All parks should inherit from this base class.\r\n * Any common functionality is implemented here to save endless re-implementations for each park.\r\n * @class\r\n */\r\nclass Park {\r\n    /**\r\n     * Create a new Park object\r\n     * @param {Object} options\r\n     * @param {String} options.name The name of this park\r\n     * @param {String} options.timezone Park's timezone\r\n     * @param {String} [options.timeFormat] Format to display park times in\r\n     * @param {String} [options.dateFormat] Format to display park dates in\r\n     * @param {Number} [options.cacheWaitTimesLength=300] How long (in seconds) to cache wait times before fetching fresh time\r\n     * @param {Number} options.latitude Park's latitude\r\n     * @param {Number} options.longitude Park's longitude\r\n     * @param {String} [options.useragent] Useragent to use when making HTTP requests\r\n     */\r\n    constructor(options = {}) {\r\n        // can only construct actual parks, not the park object itself\r\n        //  see https://stackoverflow.com/questions/29480569/does-ecmascript-6-have-a-convention-for-abstract-classes\r\n        if (new.target === Park) {\r\n            throw new TypeError(\"Cannot create Park object directly, only park implementations of Park\");\r\n        }\r\n\r\n        // take base variables from the constructor\r\n        //  these variables should be present for all parks\r\n        // what's up with these OR things?\r\n        //  by default, use any manually passed in options\r\n        //  finally, fallback on the default settings\r\n        this[s_parkName] = options.name || Settings.DefaultParkName;\r\n        this[s_parkTimezone] = options.timezone || Settings.DefaultParkTimezone;\r\n        this[s_parkTimeFormat] = options.timeFormat || Settings.DefaultParkTimeFormat;\r\n        this[s_parkDateFormat] = options.dateFormat || Settings.DefaultDateFormat;\r\n\r\n        // cache settings\r\n        //  how long wait times are cached before fetching new data\r\n        this[s_cacheTimeWaitTimes] = options.cacheWaitTimesLength;\r\n        this[s_cacheTimeOpeningTimes] = options.cacheOpeningTimesLength;\r\n\r\n        // validate park's timezone with momentjs\r\n        if (!moment.tz.zone(this[s_parkTimezone])) {\r\n            throw new Error(`Invalid timezone ${this[s_parkTimezone]} passed to park constructor.`);\r\n        }\r\n\r\n        // create a geolocation object if we've been passed a longitude and latitude\r\n        if (!this[s_parkGeolocation] && typeof(options.latitude) == \"number\" && typeof(options.longitude) == \"number\") {\r\n            this[s_parkGeolocation] = new GeoLocation({\r\n                longitude: options.longitude,\r\n                latitude: options.latitude\r\n            });\r\n        }\r\n\r\n        // validate our geolocation object has been created\r\n        if (!this[s_parkGeolocation]) {\r\n            throw new Error(`No park GeoLocation object created for ${this.name}. Please supply longitude and latitude for this park.`);\r\n        }\r\n\r\n        // set useragent, or if no useragent has been set, create a random Android one by default\r\n        this.UserAgent = options.useragent || function(ua) {\r\n            return (ua.osName == \"Android\");\r\n        };\r\n\r\n        // initialise the Rides array\r\n        this.Rides = [];\r\n        // also initialise our ride ID -> idx map\r\n        this[s_rideIDToIDXMap] = {};\r\n\r\n        // generate cache keys for this park (use cacheKey, the name of this object, _waittimes)\r\n        this[s_cacheKeyWaitTimes] = `${cacheKey}${this.constructor.name}_waittimes`;\r\n        this[s_cacheKeyOpeningTimes] = `${cacheKey}${this.constructor.name}_openingtimes`;\r\n\r\n        // make a new schedule object for storing park opening hours in\r\n        this[s_scheduleData] = new Schedule({\r\n            timeFormat: this[s_parkTimeFormat],\r\n            dateFormat: this[s_parkDateFormat],\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get waiting times for rides from this park\r\n     * If the last argument is a function, this will act as a callback.\r\n     *  Callback will call with callback(error, data)\r\n     *  Data will be null if error is present\r\n     * If the last argument is not a function, this will return a Promise.\r\n     */\r\n    GetWaitTimes() {\r\n        var callback = arguments[arguments.length - 1];\r\n        // if our last argument is a function, use it as a callback\r\n        if (typeof callback == \"function\") {\r\n            // translate the promise result into a \"classic\" callback response\r\n            this.GetWaitTimesPromise().then(function(data) {\r\n                callback(null, data);\r\n            }.bind(this), function(error) {\r\n                callback(error);\r\n            }.bind(this));\r\n            // otherwise, return a Promise object\r\n        } else {\r\n            return this.GetWaitTimesPromise();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch the ride data for the requested ID. If it doesn't exist, add a new ride to our park's ride set\r\n     * @param {Object} ride - Ride data to apply\r\n     * @param {String} ride.id - Ride's ID\r\n     * @param {String} ride.name - Ride's name\r\n     * @returns {Ride} ride - Newly created (or the existing) Ride object\r\n     */\r\n    GetRideObject(ride = {}) {\r\n        if (!ride) {\r\n            this.Dbg(\"No Ride Data supplied to GetRideObject\");\r\n            return null;\r\n        }\r\n        if (ride.id === undefined) {\r\n            this.Dbg(\"No Ride ID supplied to GetRideObject\", ride);\r\n            return null;\r\n        }\r\n        if (ride.name === undefined) {\r\n            this.Dbg(\"No Ride name supplied to GetRideObject\", ride);\r\n            return null;\r\n        }\r\n\r\n        // prepend the park's class name to the ID to attempt to ensure uniqueness\r\n        var className = this.constructor.name;\r\n        if (ride.id.substr(0, className.length) !== className) {\r\n            ride.id = `${className}_${ride.id}`;\r\n        }\r\n\r\n        // check if we don't already have this ride in our data set\r\n        if (this[s_rideIDToIDXMap][ride.id] === undefined) {\r\n\r\n            // new ride! add to our set\r\n            var newRide = new Ride({\r\n                ride_id: ride.id,\r\n                ride_name: ride.name,\r\n            });\r\n\r\n            // add our new ride to our ride list and make an ID mapping\r\n            this.Rides.push(newRide);\r\n            this[s_rideIDToIDXMap][ride.id] = this.Rides.length - 1;\r\n        }\r\n\r\n        // else, don't worry about it, fail quietly\r\n        // return the already existing ride\r\n        return this.Rides[this[s_rideIDToIDXMap][ride.id]];\r\n    }\r\n\r\n    /**\r\n     * Fetch the ride data for the requested ID. If it doesn't exist, returns null\r\n     * @param {Object} ride - Ride data to search for\r\n     * @param {String} ride.id - Ride's ID\r\n     * @returns {Ride} ride - Existing Ride object (or null if it doesn't exist)\r\n     */\r\n    FindRideObject(ride = {}) {\r\n        if (!ride) {\r\n            this.Dbg(\"No Ride Data supplied to FindRideObject\");\r\n            return null;\r\n        }\r\n        if (ride.id === undefined) {\r\n            this.Dbg(\"No Ride ID supplied to FindRideObject\", ride);\r\n            return null;\r\n        }\r\n\r\n        // prepend the park's class name to the ID to attempt to ensure uniqueness\r\n        var className = this.constructor.name;\r\n        if (ride.id.substr(0, className.length) !== className) {\r\n            ride.id = `${className}_${ride.id}`;\r\n        }\r\n\r\n        // check if we have this ride yet\r\n        if (this[s_rideIDToIDXMap][ride.id] === undefined) {\r\n            return null;\r\n        }\r\n\r\n        // return the already existing ride\r\n        return this.Rides[this[s_rideIDToIDXMap][ride.id]];\r\n    }\r\n\r\n    /**\r\n     * Set a new wait time for a ride\r\n     * @param {Object} ride - Ride data to apply\r\n     * @param {String} ride.id - Ride's ID\r\n     * @param {String} ride.name - Ride's name\r\n     * @param {Number} ride.wait_time - Ride's new wait time (set < 0 to signify inactive ride)\r\n     */\r\n    SetRideWaitTime(ride = {}) {\r\n        if (!ride) return this.Dbg(\"No Ride Data supplied\");\r\n        if (ride.id === undefined) return this.Dbg(\"No Ride ID supplied to SetRideWaitTime\", ride);\r\n        if (ride.name === undefined) return this.Dbg(\"No Ride name supplied to SetRideWaitTime\", ride);\r\n        if (ride.wait_time === undefined) return this.Dbg(\"No wait time supplied to SetRideWaitTime\", ride);\r\n\r\n        // set ride's new wait time\r\n        var rideObject = this.GetRideObject(ride);\r\n        rideObject.WaitTime = ride.wait_time;\r\n    }\r\n\r\n    /**\r\n     * Set/Update a ride's opening times\r\n     * @param {Object} ride Ride data to apply\r\n     * @param {String} ride.id Ride ID to apply schedule data for\r\n     * @param {Moment|String} [ride.date] Date for this ride schedule (will use openingTime if this is not present)\r\n     * @param {Moment|String} ride.openingTime Ride opening hour\r\n     * @param {Moment|String} ride.closingTime Ride closing hour\r\n     * @param {Moment|String} [ride.type=Operating] Ride hour type (default to \"Operating\")\r\n     */\r\n    SetRideOpeningHours(ride = {}) {\r\n        if (!ride) return this.Dbg(\"No ride data supplied (SetRideOpeningHours)\");\r\n        if (ride.id === undefined) return this.Dbg(\"No Ride ID supplied to SetRideOpeningHours\");\r\n\r\n        // find our ride using the supplied ID (don't create it if it doesn't exist)\r\n        var rideObject = this.FindRideObject(ride);\r\n        if (rideObject) {\r\n            // pass in standard schedule data object\r\n            rideObject.Schedule.SetDate(ride);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Get waiting times for rides from this park\r\n     * @returns {Promise}\r\n     */\r\n    GetWaitTimesPromise() {\r\n        return new Promise(function(resolve, reject) {\r\n            // do we actually support wait times?\r\n            if (!this.SupportsWaitTimes) {\r\n                return reject(`${this.Name} doesn't support fetching wait times`);\r\n            }\r\n\r\n            // check our cache first\r\n            Settings.Cache.get(this[s_cacheKeyWaitTimes], function(err, ridedata) {\r\n                if (!err && ridedata) {\r\n                    this.Log(`Cache hit for ${this[s_cacheKeyWaitTimes]}!`);\r\n\r\n                    // we have ridedata from the cache! apply over our current ride data\r\n                    for (var i = 0, ride; ride = ridedata[i++];) {\r\n                        // restore ride state from cache\r\n                        this.GetRideObject(ride).fromJSON(ride);\r\n                    }\r\n\r\n                    // make an array of all the ride states\r\n                    var result = [];\r\n                    for (i = 0; ride = this.Rides[i++];) {\r\n                        result.push(ride.toJSON());\r\n                    }\r\n                    return resolve(result);\r\n                }\r\n\r\n                // cache missing key or the cached data has expired. Fetch new data!\r\n                this.FetchWaitTimes().then(function() {\r\n                    // success! the this.Rides array should now be populated\r\n                    //  cache the Rides array and return result\r\n                    var result = [];\r\n                    for (var i = 0, ride; ride = this.Rides[i++];) {\r\n                        result.push(ride.toJSON());\r\n                    }\r\n\r\n                    Settings.Cache.set(this[s_cacheKeyWaitTimes], result, {\r\n                        // either use the options.cacheWaitTimesLength or the default cache time length\r\n                        ttl: this[s_cacheTimeWaitTimes] || Settings.DefaultCacheWaitTimesLength\r\n                    }, function(err) {\r\n                        if (err) {\r\n                            // if we error, console out, but don't fail (still return data)\r\n                            this.Log(\"Error setting cache data for key \", this[s_cacheKeyWaitTimes]);\r\n                        }\r\n\r\n                        // return wait time data\r\n                        resolve(result);\r\n                    }.bind(this));\r\n                }.bind(this), function(err) {\r\n                    // failed to fetch wait times, reject Promise\r\n                    return reject(`Error fetching park wait times: ${err}`);\r\n                }.bind(this));\r\n            }.bind(this));\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get opening times for this park\r\n     * If the last argument is a function, this will act as a callback.\r\n     *  Callback will call with callback(error, data)\r\n     *  Data will be null if error is present\r\n     * If the last argument is not a function, this will return a Promise.\r\n     */\r\n    GetOpeningTimes() {\r\n        var callback = arguments[arguments.length - 1];\r\n        // if our last argument is a function, use it as a callback\r\n        if (typeof callback == \"function\") {\r\n            // translate the promise result into a \"classic\" callback response\r\n            this.GetOpeningTimesPromise().then(function(data) {\r\n                callback(null, data);\r\n            }.bind(this), function(error) {\r\n                callback(error);\r\n            }.bind(this));\r\n            // otherwise, return a Promise object\r\n        } else {\r\n            return this.GetOpeningTimesPromise();\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Get opening times for this park\r\n     * @returns {Promise}\r\n     */\r\n    GetOpeningTimesPromise() {\r\n        return new Promise(function(resolve, reject) {\r\n            // do we actually support opening times?\r\n            if (!this.SupportsOpeningTimes) {\r\n                return reject(`${this.Name} doesn't support fetching opening times`);\r\n            }\r\n\r\n            // check our cache first\r\n            Settings.Cache.get(this[s_cacheKeyOpeningTimes], function(err, openingTimesData) {\r\n                if (!err && openingTimesData) {\r\n                    this.Log(`Cache hit for ${this[s_cacheKeyOpeningTimes]}!`);\r\n\r\n                    // restore schedule from cached data\r\n                    this[s_scheduleData].fromJSON(openingTimesData);\r\n\r\n                    // fetch date range to return\r\n                    return resolve(this[s_scheduleData].GetDateRange({\r\n                        startDate: moment(),\r\n                        endDate: moment().add(30, \"days\"),\r\n                    }));\r\n                }\r\n\r\n                // cache missing key or the cached data has expired. Fetch new data!\r\n                this.FetchOpeningTimes().then(function() {\r\n                    // resolve with our new schedule data\r\n                    resolve(this[s_scheduleData].GetDateRange({\r\n                        startDate: moment(),\r\n                        endDate: moment().add(30, \"days\"),\r\n                    }));\r\n\r\n                    // if the data is now dirty, cache it\r\n                    if (this[s_scheduleData].IsDirty) {\r\n                        // save schedule data in cache\r\n                        Settings.Cache.set(this[s_cacheKeyOpeningTimes], this[s_scheduleData].toJSON(), {\r\n                            // either use the options.s_cacheTimeOpeningTimes or the default cache time length\r\n                            ttl: this[s_cacheTimeOpeningTimes] || Settings.DefaultCacheOpeningTimesLength\r\n                        }, function(err) {\r\n                            if (err) {\r\n                                // if we error, console out, but don't fail (still return data)\r\n                                this.Log(\"Error setting cache data for key \", this[s_cacheKeyOpeningTimes]);\r\n                            }\r\n\r\n                            // mark data as no longer dirty (no longer needs caching)\r\n                            this[s_scheduleData].IsDirty = false;\r\n                        }.bind(this));\r\n                    }\r\n                }.bind(this), function(err) {\r\n                    // failed to fetch opening times, reject Promise\r\n                    return reject(`Error fetching park opening times: ${err}`);\r\n                }.bind(this));\r\n            }.bind(this));\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Get this park's geolocation object\r\n     * @type {GeoLocation}\r\n     * */\r\n    get Location() {\r\n        return this[s_parkGeolocation];\r\n    }\r\n\r\n    /**\r\n     * Get this park's name in a human-readable form\r\n     * @type {String}\r\n     * */\r\n    get Name() {\r\n        return this[s_parkName];\r\n    }\r\n\r\n    /**\r\n     * Get this park's useragent string for making network requests\r\n     * This is usually randomly generated on object construction\r\n     * @type {String}\r\n     */\r\n    get UserAgent() {\r\n        return this[s_useragent];\r\n    }\r\n\r\n    /**\r\n     * Set this park's useragent\r\n     * Can set user agent to a defined string or use a generator function (see random-useragent library)\r\n     * @type {string|function}\r\n     */\r\n    set UserAgent(useragent = null) {\r\n        if (!useragent) throw new Error(\"No configuration passed to UserAgent setter\");\r\n\r\n        if (typeof(useragent) == \"function\") {\r\n            // generate a useragent using a generator function\r\n            this[s_useragent] = random_useragent.getRandom(useragent);\r\n        } else if (typeof(useragent) == \"string\") {\r\n            // set useragent using supplied static string\r\n            this[s_useragent] = useragent;\r\n        } else {\r\n            throw new Error(\"Must define either static user agent string or a generator function\");\r\n        }\r\n\r\n        this.Log(\"Set useragent to \" + this.UserAgent);\r\n    }\r\n\r\n    /**\r\n     * Get this park's Timezone\r\n     * @type {String}\r\n     * */\r\n    get Timezone() {\r\n        return this[s_parkTimezone];\r\n    }\r\n\r\n    /**\r\n     * Get park's current time\r\n     * @param {Object} timeFormatObject\r\n     * @param {String} [timeFormatObject.timeFormat] Moment JS format string to format time as \r\n     * @returns {String} Time as formatted by park's timeformat, or the default timeformat if set to null\r\n     * */\r\n    TimeNow({\r\n        timeFormat = null\r\n    } = {}) {\r\n        // take time right now, convert now into park's timezone and format it\r\n        //  format in preferred order of, manually passed in format, park's default time format, or global default time format\r\n        return moment().tz(this.Timezone).format(timeFormat || this[s_parkTimeFormat] || DefaultTimeFormat);\r\n    }\r\n\r\n    /**\r\n     * Get park's current date\r\n     * @param {Object} dateFormatObject\r\n     * @param {String} [dateFormatObject.dateFormat] Moment JS format string to format date as \r\n     * @returns {String} Date as formatted by park's dateFormat, or the default dateFormat if set to null\r\n     * */\r\n    DateNow({\r\n        dateFormat = null\r\n    } = {}) {\r\n        // we're just calling the TimeNow function with a date formate string instead\r\n        return this.TimeNow({\r\n            timeFormat: dateFormat || this[s_parkDateFormat]\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the park's raw schedule object\r\n     * @returns {Schedule} Schedule object for this park's opening times\r\n     */\r\n    get Schedule() {\r\n        return this[s_scheduleData];\r\n    }\r\n\r\n    /**\r\n     * Does this park offer fast-pass services?\r\n     * @type {Boolean}\r\n     */\r\n    get FastPass() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this park offer wait time information?\r\n     * @type {Boolean}\r\n     */\r\n    get SupportsWaitTimes() {\r\n        // base this logic solely on the presence of a function \"FetchWaitTimes\" existing\r\n        return this.FetchWaitTimes !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Does this park offer opening time information?\r\n     * @type {Boolean}\r\n     */\r\n    get SupportsOpeningTimes() {\r\n        // base this logic solely on the presence of a function \"FetchOpeningTimes\" existing\r\n        return this.FetchOpeningTimes !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Does this park offer opening times for rides?\r\n     * @type {Boolean}\r\n     */\r\n    get SupportsRideSchedules() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Debug print a message (when NODE_DEBUG=themeparks is set in environment)\r\n     * @param {...*} ToPrint Objects/strings to print\r\n     * */\r\n    Log() {\r\n        return DebugLog(`${this.constructor.name}:`, ...arguments);\r\n    }\r\n}\r\n\r\n// export the Park class\r\nmodule.exports = Park;"]}